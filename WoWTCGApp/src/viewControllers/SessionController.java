/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * SessionController.java
 *
 * Created on 15-aug-2012, 14:32:23
 */
package viewControllers;

import images.ImageLoader;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLayeredPane;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import model.Card;
import model.CardSnapshot;
import model.Deck;
import network.ConnectionProxy;
import network.MessageHandler;

/**
 *
 * @author Robin jr
 */
public class SessionController extends javax.swing.JPanel implements MouseListener, MouseMotionListener, MessageHandler {
    
    /** Creates new form SessionController */
    public SessionController(MainFrame callback, Deck playerDeck) {
	this.parent = callback;
	this.deck = playerDeck;
	
	// create menu
	this.sessionMenu = new JMenu("Session");
	this.sessionMenu.setBorder(BorderFactory.createLineBorder(Color.GRAY, 1));
	this.sessionMenu.setBorderPainted(false);
	this.sessionMenu.addMouseListener(new java.awt.event.MouseAdapter() {
	    @Override
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                sessionMenuMouseEntered(evt);
            }
	    @Override
            public void mouseExited(java.awt.event.MouseEvent evt) {
                sessionMenuMouseExited(evt);
            }
        });
	
	JMenuItem stop = new JMenuItem("Stop session...");
	stop.addActionListener(new ActionListener() {

	    @Override
	    public void actionPerformed(ActionEvent e) {
		parent.removeMenu(sessionMenu);
		parent.stopSession();
	    }
	});
	this.sessionMenu.add(stop);
	
	parent.addMenu(sessionMenu);
	
	initComponents();
	
	styleComponents();
    }
    
    private void sessionMenuMouseEntered(MouseEvent e){
	this.sessionMenu.setBorderPainted(true);
    }
    
    private void sessionMenuMouseExited(MouseEvent e){
	this.sessionMenu.setBorderPainted(false);
    }
    
    private void styleComponents(){
	this.deckOutlet.setIcon(ImageLoader.scaleImage(ImageLoader.createImageIconAtHomeLocation("template.png"), this.deckOutlet.getPreferredSize()));
	this.previewOutlet.setIcon(ImageLoader.scaleImage(ImageLoader.createImageIconAtHomeLocation("template.png"), this.previewOutlet.getPreferredSize()));
    }
    
    /**
     * Sets the preview image to the specified icon. Automatically resizes to fit the preview (does not respect aspect ratio).
     * 
     * @param icon 
     */
    public void setPreview(ImageIcon icon){
	this.previewOutlet.setIcon(ImageLoader.scaleImage(icon, this.previewOutlet.getPreferredSize()));
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        sideSplit = new javax.swing.JSplitPane();
        masterSplit = new javax.swing.JSplitPane();
        statusPanel = new javax.swing.JPanel();
        statusOutlet = new javax.swing.JLabel();
        gamePanel = new javax.swing.JSplitPane();
        mainSplit = new javax.swing.JSplitPane();
        handOutlet = new javax.swing.JPanel();
        tableOutlet = new javax.swing.JLayeredPane();
        sidePanel = new javax.swing.JPanel();
        cardsPanel = new javax.swing.JPanel();
        graveyardOutlet = new javax.swing.JButton();
        removedFromTheGameOutlet = new javax.swing.JButton();
        deckOutlet = new javax.swing.JButton();
        playersSplit = new javax.swing.JSplitPane();
        vsPanel = new javax.swing.JPanel();
        vsNameOutlet = new javax.swing.JLabel();
        playerPanel = new javax.swing.JPanel();
        playerNameOutlet = new javax.swing.JLabel();
        previewPanel = new javax.swing.JPanel();
        previewOutlet = new javax.swing.JLabel();

        sideSplit.setBorder(null);
        sideSplit.setDividerLocation(500);
        sideSplit.setDividerSize(1);
        sideSplit.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        sideSplit.setResizeWeight(1.0);
        sideSplit.setEnabled(false);
        sideSplit.setFocusable(false);
        sideSplit.setMaximumSize(new java.awt.Dimension(150, 2147483647));
        sideSplit.setMinimumSize(new java.awt.Dimension(150, 0));
        sideSplit.setPreferredSize(new java.awt.Dimension(150, 800));
        sideSplit.setRequestFocusEnabled(false);

        setMaximumSize(new java.awt.Dimension(1440, 800));
        setMinimumSize(new java.awt.Dimension(1440, 800));
        setPreferredSize(new java.awt.Dimension(1440, 800));
        setLayout(new java.awt.BorderLayout());

        masterSplit.setBorder(null);
        masterSplit.setDividerLocation(30);
        masterSplit.setDividerSize(0);
        masterSplit.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        masterSplit.setEnabled(false);
        masterSplit.setFocusable(false);
        masterSplit.setMinimumSize(new java.awt.Dimension(1440, 800));
        masterSplit.setPreferredSize(new java.awt.Dimension(1440, 800));
        masterSplit.setRequestFocusEnabled(false);

        statusPanel.setMaximumSize(new java.awt.Dimension(1440, 30));
        statusPanel.setMinimumSize(new java.awt.Dimension(1440, 30));
        statusPanel.setPreferredSize(new java.awt.Dimension(1440, 30));

        statusOutlet.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        statusOutlet.setText("Status");
        statusOutlet.setFocusable(false);
        statusOutlet.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        statusOutlet.setRequestFocusEnabled(false);

        javax.swing.GroupLayout statusPanelLayout = new javax.swing.GroupLayout(statusPanel);
        statusPanel.setLayout(statusPanelLayout);
        statusPanelLayout.setHorizontalGroup(
            statusPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1442, Short.MAX_VALUE)
            .addGroup(statusPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(statusOutlet, javax.swing.GroupLayout.PREFERRED_SIZE, 1440, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        statusPanelLayout.setVerticalGroup(
            statusPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 30, Short.MAX_VALUE)
            .addGroup(statusPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(statusOutlet, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        masterSplit.setTopComponent(statusPanel);

        gamePanel.setDividerLocation(150);
        gamePanel.setDividerSize(2);
        gamePanel.setEnabled(false);
        gamePanel.setFocusable(false);
        gamePanel.setPreferredSize(new java.awt.Dimension(1440, 800));
        gamePanel.setRequestFocusEnabled(false);

        mainSplit.setBorder(null);
        mainSplit.setDividerLocation(600);
        mainSplit.setDividerSize(2);
        mainSplit.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        mainSplit.setResizeWeight(1.0);
        mainSplit.setEnabled(false);
        mainSplit.setFocusable(false);
        mainSplit.setRequestFocusEnabled(false);

        handOutlet.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));
        mainSplit.setBottomComponent(handOutlet);
        mainSplit.setTopComponent(tableOutlet);

        gamePanel.setRightComponent(mainSplit);

        sidePanel.setEnabled(false);
        sidePanel.setFocusable(false);
        sidePanel.setMaximumSize(new java.awt.Dimension(150, 32767));
        sidePanel.setMinimumSize(new java.awt.Dimension(150, 0));
        sidePanel.setPreferredSize(new java.awt.Dimension(150, 800));
        sidePanel.setLayout(new java.awt.BorderLayout());

        cardsPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        cardsPanel.setMaximumSize(new java.awt.Dimension(150, 300));
        cardsPanel.setMinimumSize(new java.awt.Dimension(150, 300));
        cardsPanel.setPreferredSize(new java.awt.Dimension(150, 300));
        cardsPanel.setLayout(new java.awt.GridBagLayout());

        graveyardOutlet.setText("Gy");
        graveyardOutlet.setPreferredSize(new java.awt.Dimension(60, 60));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 5);
        cardsPanel.add(graveyardOutlet, gridBagConstraints);

        removedFromTheGameOutlet.setText("RftG");
        removedFromTheGameOutlet.setPreferredSize(new java.awt.Dimension(60, 60));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 0);
        cardsPanel.add(removedFromTheGameOutlet, gridBagConstraints);

        deckOutlet.setPreferredSize(new java.awt.Dimension(130, 200));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.gridheight = 5;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 0, 0);
        cardsPanel.add(deckOutlet, gridBagConstraints);

        sidePanel.add(cardsPanel, java.awt.BorderLayout.PAGE_END);

        playersSplit.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        playersSplit.setDividerLocation(125);
        playersSplit.setDividerSize(1);
        playersSplit.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        playersSplit.setResizeWeight(0.5);
        playersSplit.setEnabled(false);
        playersSplit.setFocusable(false);
        playersSplit.setMaximumSize(new java.awt.Dimension(150, 2454578));
        playersSplit.setMinimumSize(new java.awt.Dimension(150, 0));
        playersSplit.setPreferredSize(new java.awt.Dimension(150, 250));
        playersSplit.setRequestFocusEnabled(false);

        vsPanel.setFocusable(false);
        vsPanel.setMaximumSize(new java.awt.Dimension(150, 32767));
        vsPanel.setMinimumSize(new java.awt.Dimension(150, 0));
        vsPanel.setPreferredSize(new java.awt.Dimension(150, 125));

        vsNameOutlet.setText("Enemy");

        javax.swing.GroupLayout vsPanelLayout = new javax.swing.GroupLayout(vsPanel);
        vsPanel.setLayout(vsPanelLayout);
        vsPanelLayout.setHorizontalGroup(
            vsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(vsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(vsNameOutlet)
                .addContainerGap(106, Short.MAX_VALUE))
        );
        vsPanelLayout.setVerticalGroup(
            vsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(vsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(vsNameOutlet)
                .addContainerGap(99, Short.MAX_VALUE))
        );

        playersSplit.setTopComponent(vsPanel);

        playerPanel.setFocusable(false);
        playerPanel.setMaximumSize(new java.awt.Dimension(150, 4578787));
        playerPanel.setMinimumSize(new java.awt.Dimension(150, 0));
        playerPanel.setPreferredSize(new java.awt.Dimension(150, 125));

        playerNameOutlet.setText("Player");

        javax.swing.GroupLayout playerPanelLayout = new javax.swing.GroupLayout(playerPanel);
        playerPanel.setLayout(playerPanelLayout);
        playerPanelLayout.setHorizontalGroup(
            playerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(playerPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(playerNameOutlet)
                .addContainerGap(108, Short.MAX_VALUE))
        );
        playerPanelLayout.setVerticalGroup(
            playerPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(playerPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(playerNameOutlet)
                .addContainerGap(116, Short.MAX_VALUE))
        );

        playersSplit.setRightComponent(playerPanel);

        sidePanel.add(playersSplit, java.awt.BorderLayout.CENTER);

        previewPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        previewPanel.setEnabled(false);
        previewPanel.setFocusable(false);
        previewPanel.setMaximumSize(new java.awt.Dimension(150, 2147483647));
        previewPanel.setMinimumSize(new java.awt.Dimension(150, 0));
        previewPanel.setPreferredSize(new java.awt.Dimension(150, 200));
        previewPanel.setRequestFocusEnabled(false);
        previewPanel.setLayout(new java.awt.BorderLayout());

        previewOutlet.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        previewOutlet.setBorder(javax.swing.BorderFactory.createTitledBorder("Preview"));
        previewOutlet.setPreferredSize(new java.awt.Dimension(130, 182));
        previewPanel.add(previewOutlet, java.awt.BorderLayout.CENTER);

        sidePanel.add(previewPanel, java.awt.BorderLayout.PAGE_START);

        gamePanel.setLeftComponent(sidePanel);

        masterSplit.setBottomComponent(gamePanel);

        add(masterSplit, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel cardsPanel;
    private javax.swing.JButton deckOutlet;
    private javax.swing.JSplitPane gamePanel;
    private javax.swing.JButton graveyardOutlet;
    private javax.swing.JPanel handOutlet;
    private javax.swing.JSplitPane mainSplit;
    private javax.swing.JSplitPane masterSplit;
    private javax.swing.JLabel playerNameOutlet;
    private javax.swing.JPanel playerPanel;
    private javax.swing.JSplitPane playersSplit;
    private javax.swing.JLabel previewOutlet;
    private javax.swing.JPanel previewPanel;
    private javax.swing.JButton removedFromTheGameOutlet;
    private javax.swing.JPanel sidePanel;
    private javax.swing.JSplitPane sideSplit;
    private javax.swing.JLabel statusOutlet;
    private javax.swing.JPanel statusPanel;
    private javax.swing.JLayeredPane tableOutlet;
    private javax.swing.JLabel vsNameOutlet;
    private javax.swing.JPanel vsPanel;
    // End of variables declaration//GEN-END:variables
    
    private final JMenu sessionMenu;
    
    private MainFrame parent;
    
    private ArrayList<String> hand;
    private ArrayList<String> graveyard;
    private ArrayList<String> removedftgame;
    // drag from hand:
    private boolean draggingFromHand = false;
    private Point draggingFromHandLastLocation = null;
    private String draggingFromHandCardName = null;
    private CardPanel draggingFromHandCardPanel = null;
    private boolean draggingFromHandCardPanelShown = false;
    private Deck deck;
    private boolean dragging = false;
    private CardPanel draggedCard;
    private static final int GRIDX = 20, GRIDY = 20;
    private List<CardPanel> cards = new ArrayList<CardPanel>();
    /**
     * Registered a mouse click
     * 
     * MAYBE: ADD SELECTED STATE TO PANELS AND ALLOW KEYBOARD INTERACTION?
     * 
     * @param e 
     */
    @Override
    public void mouseClicked(MouseEvent e) {
	// determine the card that was clicked
	Component c = tableOutlet.findComponentAt(e.getX(), e.getY());
	if (!(c.getParent() instanceof CardPanel)) {
	    return;
	}
	c = c.getParent(); // change c to the panel
	final CardPanel clickedCard = (CardPanel) c;
	
//	System.out.println("Clicked on "+c.toString());

	final Point clickedLocation = e.getLocationOnScreen();

	// on right click, make a JPopupDialog
	if (e.getButton() == MouseEvent.BUTTON3) {
	    JPopupMenu popup = new JPopupMenu();

	    JMenuItem readItem = new JMenuItem("Read card...");
	    readItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    //
		    //System.out.println("STUB :: Read card clicked");
		    clickedCard.showCard(clickedLocation);
		}
	    });

	    popup.add(readItem);

	    popup.addSeparator();

	    JMenuItem menuItem = new JMenuItem("Exhaust");
	    if (clickedCard.isExhausted()) {
		menuItem.setText("Ready");
	    }
	    menuItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    //System.out.println("Clicked cardPanel: "+clickedCard.getName());
		    clickedCard.toggleExhaust();
		}
	    });
	    popup.add(menuItem);

	    JMenuItem flipItem = new JMenuItem("Flip");
	    flipItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    clickedCard.toggleFlip();
//		    if (state == ONLINE) {
//			connection.sendSnapshot(clickedCard.getGUID(), clickedCard.getSnapshot());
//		    }
		}
	    });
	    popup.add(flipItem);

	    popup.addSeparator();

	    JMenuItem countersItem = new JMenuItem("Set Counters...");
	    countersItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    boolean validInput = false;
		    int res = 0;
		    do {
			try {
			    String resString = JOptionPane.showInputDialog(new JFrame(), "Counters:", clickedCard.getCounters());

			    // close or cancel
			    if (resString == null) {
				break;
			    }

			    res = Integer.parseInt(resString);

			    //if(resString == JOptionPane.CANCEL_OPTION)

			    validInput = true;
			} catch (Exception ex) {
			    System.err.println("Caught an error: " + ex);
			    // learn to enter numbers faggots
			}

		    } while (!validInput);

		    if (validInput) {
			clickedCard.setCounters(res);
//			if (state == ONLINE) {
//			    connection.sendSnapshot(clickedCard.getGUID(), clickedCard.getSnapshot());
//			}
		    }
		}
	    });

//	    popup.add(countersItem);

	    JMenuItem addCounterItem = new JMenuItem("Add Counter");
	    addCounterItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    clickedCard.setCounters(clickedCard.getCounters() + 1);

//		    if (state == ONLINE) {
//			connection.sendSnapshot(clickedCard.getGUID(), clickedCard.getSnapshot());
//		    }
		}
	    });

	    popup.add(addCounterItem);

	    JMenuItem removeCounterItem = new JMenuItem("Remove Counter");
	    removeCounterItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    clickedCard.setCounters(clickedCard.getCounters() - 1);

//		    if (state == ONLINE) {
//			connection.sendSnapshot(clickedCard.getGUID(), clickedCard.getSnapshot());
//		    }
		}
	    });

	    popup.add(removeCounterItem);

	    popup.add(countersItem);

	    popup.addSeparator();

	    JMenuItem controlItem = new JMenuItem("Take Control!");
	    if (clickedCard.isMyCard()) {
		controlItem.setText("Give Control");
	    }
	    controlItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    System.out.println("STUB :: Switching control of card!");
		}
	    });

	    popup.add(controlItem);

	    popup.addSeparator();

	    JMenuItem toHandItem = new JMenuItem("To Hand");
	    toHandItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    //System.out.println("STUB :: Moving card to hand");
		    moveCardToHandFromPlay(clickedCard);
		}
	    });

	    popup.add(toHandItem);

	    JMenuItem graveyardItem = new JMenuItem("To Graveyard");
	    graveyardItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    //System.out.println("STUB :: Moving card to graveyard");
		    moveCardToGraveyardFromPlay(clickedCard);
		}
	    });

	    popup.add(graveyardItem);

	    JMenuItem toDeckItem = new JMenuItem("To Top Of Deck");
	    toDeckItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    System.out.println("STUB :: Moving card to top of deck");
		}
	    });

	    popup.add(toDeckItem);

	    JMenuItem removeFromGameItem = new JMenuItem("Remove From Game");
	    removeFromGameItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    System.out.println("STUB :: Removing from the game");
		}
	    });

	    popup.add(removeFromGameItem);

	    popup.addSeparator();

	    // add to top, one to top, one to bot, to bot

	    JMenuItem toTopItem = new JMenuItem("Bring To Top");
	    toTopItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
//		    clickedCard.toFront(getTopLayer()+1);

		    // remove it and add it to the back = put on top
		    cards.remove(clickedCard);
		    cards.add(clickedCard);

//		    redrawCard(clickedCard);

		    redrawAllCards();
		}
	    });
	    popup.add(toTopItem);

	    JMenuItem oneUpItem = new JMenuItem("Move One Up");
	    oneUpItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    // remove it and add it to its previous place + 1
		    int index = cards.indexOf(clickedCard);
		    if (index < cards.size() - 1) {
			cards.remove(clickedCard);
			cards.add(index + 1, clickedCard);
		    }

		    redrawAllCards();
		}
	    });
	    popup.add(oneUpItem);

	    JMenuItem oneDownItem = new JMenuItem("Move One Down");
	    oneDownItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
		    // remove it and add it to its previous place - 1
		    int index = cards.indexOf(clickedCard);
		    if (index > 0) {
			cards.remove(clickedCard);
			cards.add(index - 1, clickedCard);
		    }

		    redrawAllCards();
		}
	    });
	    popup.add(oneDownItem);

	    JMenuItem toBackItem = new JMenuItem("Bring To Back");
	    toBackItem.addActionListener(new ActionListener() {

		@Override
		public void actionPerformed(ActionEvent e) {
//		    clickedCard.toFront(getTopLayer()+1);

		    // remove it and add it to the front = put in top
		    cards.remove(clickedCard);
		    cards.add(0, clickedCard);

//		    redrawCard(clickedCard);

		    redrawAllCards();
		}
	    });
	    popup.add(toBackItem);

	    popup.show(c, e.getX() - c.getX(), e.getY() - c.getY());
	} else if (e.getButton() == MouseEvent.BUTTON1 && e.isShiftDown()) {
	    clickedCard.toggleExhaust();
//	    this.repaint();
	    System.out.println(" should exhaust ");
	    
	} else if (e.getButton() == MouseEvent.BUTTON1 && e.isControlDown()) {
	    
	    System.out.println("should delete");
	    
	    // ctrl+click -> card to graveyard
	    moveCardToGraveyardFromPlay(clickedCard);
	} 
    }

    /**
     * MAKE SURE THIS ONLY WORKS FOR CARDS THAT I OWN
     * 
     * Maybe: dress up the dragged card (add border or just semi transparent color layer)
     * DOESNT WORK, AT LEAST NOT WITH BORDERS FOR SOME ODD REASON
     * 
     * @param e 
     */
    @Override
    public void mousePressed(MouseEvent e) {
	// only drag with left mouse button
//	if (e.getButton() == MouseEvent.BUTTON1 && !dragging && !e.isControlDown()) {
	if (e.getButton() == MouseEvent.BUTTON1 && !dragging && !e.isControlDown() && !e.isShiftDown()) {
	    
	    System.out.println("should start drag");
	    
	    if(e.isControlDown()) return;
	    
	    // reset drag and start
	    draggedCard = null;
	    dragging = true;

	    // find component that was clicked
	    Component c = tableOutlet.findComponentAt(e.getX(), e.getY());
	    if (!(c.getParent() instanceof CardPanel)) {
		return;
	    }
	    c = c.getParent(); // change c to the panel

	    // find location of click
	    Point compLoc = c.getLocation();

	    // find card and register it as drag card
	    draggedCard = (CardPanel) c;

	    System.out.println("Clicked on card " + draggedCard.getCardName() + " on layer " + tableOutlet.getLayer(c));

	    // pick up card
	    draggedCard.setLocation(compLoc);
	    draggedCard.setBounds((int) compLoc.getX(), (int) compLoc.getY(), (int) c.getWidth(), (int) c.getHeight());

	    // remove card from its layer and add to drag layer
	    tableOutlet.remove(draggedCard);
	    tableOutlet.add(draggedCard, JLayeredPane.DRAG_LAYER);

	    // trigger redraw
	    tableOutlet.validate();

	    // set cursor to drag
	    tableOutlet.setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
	}
    }

    /**
     * gets triggered after ctrl-c + alt-c
     * 
     * @param e 
     */
    @Override
    public void mouseReleased(MouseEvent e) {
	dragging = false;
	if (e.getButton() == MouseEvent.BUTTON1) {
//	    if (!dragging || draggedCard == null) {
//		return;
//	    } else {
//		dragging = false;
//	    }
	    if(draggedCard == null){
		return;
	    }

	    // reset cursor
	    tableOutlet.setCursor(null);

	    // remove card from drag layer
	    tableOutlet.remove(draggedCard);

	    // add card to its previous layer
	    tableOutlet.add(draggedCard, new Integer(JLayeredPane.PALETTE_LAYER + cards.indexOf(draggedCard)));

	    System.out.println("Released card " + draggedCard.getCardName() + " on layer " + tableOutlet.getLayer(draggedCard));

	    // broadcast this!!
	   
	}
    }

    @Override
    public void mouseEntered(MouseEvent e) {
    }

    @Override
    public void mouseExited(MouseEvent e) {
    }

    @Override
    public void mouseDragged(MouseEvent e) {
	
	// is called fast
	
	if (e.getButton() == MouseEvent.BUTTON1) {
	    if (draggedCard == null) {
		return;
	    }
	    if (!dragging) {
		dragging = true;
	    }

	    //	int x = e.getX()+dx;
	    int x = e.getX() - 10;
	    //	int y = e.getY()+dy;
	    int y = e.getY() - 10;

	    // snap to grid
	    x /= GRIDX;
	    x *= GRIDX;

	    y /= GRIDY;
	    y *= GRIDY;
	    
//	    if(x<0)x=0;
//	    if(x+draggedCard.getWidth()>mainPanel.getWidth())
//	    if(y<mainPanel.getLocationOnScreen().getY()) y = mainPanel.getY();
//	    if(y+draggedCard.getHeight()>=mainPanel.getHeight()+mainPanel.getY()) y = mainPanel.getHeight()+mainPanel.getY();

	    // redraw the card at its new location
	    draggedCard.setLocation(x, y);
	}
    }

    @Override
    public void mouseMoved(MouseEvent e) {
    }

    public void startSession(ConnectionProxy conn) {
	// have connection
//	this.connection = conn;

	// put hero card into play
	spawnCard(deck.getHero());
	
//	startGame(ONLINE);
    }


    private void resetLayout() {
	// empty hand

	// clear everything on the table
	tableOutlet.removeAll();

	// add background again
    }

    private void redrawAllCards() {
	tableOutlet.removeAll();

//	for (CardPanel cardPanel : myCards) {
//	    mainPanel.add(cardPanel, new Integer(JLayeredPane.PALETTE_LAYER+myCards.indexOf(cardPanel)));
//	}
	for (int i = 0; i < cards.size(); i++) {
	    tableOutlet.add(cards.get(i), new Integer(JLayeredPane.PALETTE_LAYER + i));
	}

	tableOutlet.validate();
    }

    private void drawCard(int amount) {
	for (int i = 0; i < amount; i++) {
	    Card drawn = deck.drawCard();
	    if (drawn != null) {
		hand.add(drawn.getName());
	    } else {
		// DECK IS EMPTY
		JOptionPane.showMessageDialog(new JFrame(), "Your deck is empty!", "Can't draw card", JOptionPane.ERROR_MESSAGE);
		break;
	    }
//	    sendMessage("drawing a card");
	}

//	leftList.setListData(hand.toArray(new String[0]));
    }

    private void playCardFromHand(String cardName) {
//	Card card = model.generateCardByName(model.getCardByName(cardName).getType(), cardName);
//
//	if (card != null) {
//	    CardPanel cardPanel = new CardPanel(card, cards.size());
//	    cardPanel.setBounds(40, 40, 60, 60);
//
//	    addToPlay(cardPanel);
//
////	    if (state == ONLINE) {
////		//send gui update
////		connection.sendGUIMessage(cardPanel);
////	    }
////	    sendMessage("playing " + card.getName().toUpperCase() + " from HAND");
//
//	    // remove card from hand
//	    hand.remove(cardName);
//	}
//
//	leftList.setListData(hand.toArray(new String[0]));
//	leftList.clearSelection();
//	leftList.validate();
    }

    private void spawnCard(String cardName) {
//	Card card = model.generateCardByName(model.getCardByName(cardName).getType(), cardName);
//
//	if (card != null) {
//	    CardPanel cardPanel = new CardPanel(card, cards.size());
//	    cardPanel.setBounds(40, 40, 60, 60);
//
//	    addToPlay(cardPanel);
//
////	    if (state == ONLINE) {
////		//send gui update
////		connection.sendGUIMessage(cardPanel);
////	    }
//	}
    }

    /**
     * Supposed to be called by receiveForeignCard
     * 
     * @param cardName
     * @param GUID 
     */
    private void spawnCardWithGUID(String cardName, String GUID) {
//	Card card = model.generateCardByName(model.getCardByName(cardName).getType(), cardName);
//
//	if (card != null) {
//	    CardPanel cardPanel = new CardPanel(card, cards.size(), GUID);
//	    cardPanel.setBounds(40, 40, 60, 60);
//
//	    addToPlay(cardPanel);
//
////	    if (state == ONLINE) {
////		connection.sendGUIMessage(cardPanel);
////	    }
//	}
    }

    private void addToPlay(CardPanel cardPanel) {
	System.out.println("Adding a card to play (" + cardPanel.getCardName() + ")!");

	cards.add(cardPanel);

//	int layer = new Integer(JLayeredPane.PALETTE_LAYER + cards.indexOf(cardPanel));

	tableOutlet.add(cardPanel, new Integer(JLayeredPane.PALETTE_LAYER + cards.indexOf(cardPanel)));
	tableOutlet.validate();
	tableOutlet.repaint();
    }

    private void addToPlay(CardPanel cardPanel, Point loc) {
	cardPanel.setLocation(loc);
	addToPlay(cardPanel);
    }

    private void moveCardToHandFromPlay(CardPanel cardPanel) {
	tableOutlet.remove(cardPanel);

	cardPanel.setVisible(false);
	hand.add(cardPanel.getCard().getName());
//	leftList.setListData(hand.toArray(new String[0]));

	tableOutlet.validate();
	tableOutlet.repaint();
    }

    private void moveCardToGraveyardFromPlay(CardPanel cardPanel) {
	cardPanel.setVisible(false);
	
	cards.remove(cardPanel);
	tableOutlet.remove(cardPanel);

	
	// add to top
	graveyard.add(0, cardPanel.getCard().getName());

	tableOutlet.validate();
	tableOutlet.repaint();
    }

    // Message Handler protocol
    @Override
    public void receiveTextMessage(String msg) {
//	addToChat("Stranger: " + msg);
    }

    @Override
    public void receiveForeignCard(CardPanel cardPanel) {
	addToPlay(cardPanel);
    }

    @Override
    public void moveCardWithGUIDToLocation(String GUID, Point location) {
	CardPanel moveMe = findCardPanelForGUID(GUID);
	if (moveMe != null) {
	    moveMe.setLocation(location);
	}
	tableOutlet.validate();
    }

    @Override
    public void applySnapshotToCardWithGUID(String GUID, CardSnapshot snapshot) {
	CardPanel changeMe = findCardPanelForGUID(GUID);
	if (changeMe != null) {
	    changeMe.applySnapshot(snapshot);
	}
	tableOutlet.validate();
    }
    
    
    private void rollDie(int sides) {
	int outcome = 1 + (int) (Math.random() * sides);
//	sendMessage("rolled a " + outcome + " with a " + sides + " sided die!");
    }

    private CardPanel findCardPanelForGUID(String GUID) {
	CardPanel ret = null;
	for (CardPanel cardPanel : cards) {
	    if (cardPanel.getGUID().compareTo(GUID) == 0) {
		ret = cardPanel;
		break;
	    }
	}
	return ret;
    }

    private boolean isMyCardPanel(String GUID) {
	boolean ret = false;
	for (CardPanel cardPanel : cards) {
	    if (cardPanel.getGUID().compareTo(GUID) == 0) {
		ret = true;
		break;
	    }
	}
	return ret;
    }
}
